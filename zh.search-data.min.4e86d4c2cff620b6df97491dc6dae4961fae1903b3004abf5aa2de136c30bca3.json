[{"id":0,"href":"/docs/other/git-branch-theory-analysis/","title":"Git分支原理解析","section":"其他","content":"前言 #  1991年Linus Torvalds发明了linux内核,从此不断发展壮大,成为当前最流行操作系统之一 2002年,linus选用商业版本控制系统BitKeeper——Bitmover公司,来管理代码 2005年,linux花费十天时间用C写了一个分布式版本控制系统——git,一个月之内linux源码已用git管理 2016年,BitKeeper开源\ngit分支 #  // 进行一次提交,看git的工作原理 $ git add README test.rb LICENSE $ git commit -m 'The initial commit of my project' // 一个commit对象 包含指向快照的指针,作者姓名,邮箱,提交信息等,还包括指向树对象的指针 // 现在，Git 仓库中有五个对象： // 三个 blob 对象（保存着文件快照） // 一个 tree 对象 （记录着目录结构和 blob 对象索引） // 一个commit对象 包含指向快照的指针,作者姓名,邮箱,等所有提交信息,还包括指向tree对象的指针,父对象的指针 第一次提交没有父对象,之后提交父对象指向上次提交 创建分支 #  $ git branch testing git有一个特殊的HEAD指针,指向当前分支 $ git switch testing //切换分支只是更改了HEAD指针的指向 // 不妨提交一次 $ vim test.rb $ git commit -a -m 'made a change' // testing分支向前移动 // 切回master分支, HEAD指向master,工作区恢复到master所指向的快照内容 $ git switch master // 不妨再做次提交 $ vim test.rb $ git commit -a -m 'made other changes' // 出现了历史性的分叉 分支合并 #  // 新建一个分支iss53,并切换到该分支 $ git checkout -b iss53 Switched to a new branch \u0026quot;iss53\u0026quot; $ vim index.html $ git commit -a -m 'added a new footer [issue 53]' // 做一次提交,iss53向前推进 $ git checkout master $ git checkout -b hotfix $ git commit -a -m 'fixed the broken email address' // 切回master分支 // 创建新分支hotfix,并切换到该分支 // 做次提交 $ git checkout master $ git merge hotfix // 切换到master, 合并hotfix分支 // 当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支 // 那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移） // 因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 $ git branch -d hotfix // 合并过后该分支已无用,应删除 $ git checkout iss53 $ git commit -a -m 'finished the new footer [issue 53]' // 切回iss53分支,继续我们的工作 $ git checkout master $ git merge iss53 // 现已经修复了iss53,把它合并到master上 你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。 $ git branch -d iss53 // 删除该分支 合并方式 #  $ git merge --no-ff {branch} // 使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法 "},{"id":1,"href":"/docs/golang/pkg/viper/","title":"Viper","section":"Pkg","content":"前言 #  版本 v1.7.0\n更详细文档请移步至官方文档\n读取文件 #  viper.SetConfigName(\u0026#34;config\u0026#34;) // 文件名 viper.SetConfigType(\u0026#34;yaml\u0026#34;) // 扩展名 viper.AddConfigPath(\u0026#34;.\u0026#34;) // 添加路径 viper.ReadInConfig() // 读取 写入文件 #  // 写入当前配置路径文件 (by \u0026#39;viper.AddConfigPath()\u0026#39; and \u0026#39;viper.SetConfigName()\u0026#39;) viper.WriteConfig()\t// 覆盖 viper.SafeWriteConfig()\t// 不覆盖 // 写入指定的配置文件 viper.WriteConfigAs(\u0026#34;/path/to/my/.config\u0026#34;) // 覆盖 viper.SafeWriteConfigAs(\u0026#34;/path/to/my/.config\u0026#34;) // 不覆盖 运行时重读 #  无需重启服务\nviper.WatchConfig()\t// 告诉viper，监听配置，更改时重新载入 // 配置变更事件 viper.OnConfigChange(func(e fsnotify.Event) { fmt.Println(\u0026#34;Config file changed:\u0026#34;, e.Name) // 做一些有趣的事情，like, viper.Unmarshal to update config }) 从io.Reader读取 #  viper.SetConfigType(\u0026#34;toml\u0026#34;)\t// 设置配置类型 var configExample = `debug = true`\t// 定义配置内容 viper.ReadConfig(bytes.NewBufferString(configExample))\t// bytes.Buffer实现了io.Reader接口 fmt.Println(viper.GetBool(\u0026#34;debug\u0026#34;)) // true 设置配置 #  viper.SetDefault(\u0026#34;debug\u0026#34;, false)\t// 设置默认值 viper.SetDefault(\u0026#34;jwt\u0026#34;, map[string]string{\u0026#34;aglo\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;secret\u0026#34;: \u0026#34;\u0026#34;})\t// 更复杂结构 viper.Set(\u0026#34;debug\u0026#34;, true)\t// 有时我们需要在程序逻辑中更改或命令行flag来控制 别名 #  多个键引用一个值, 如果配置名称需变更，无需改动业务程序\nviper.RegisterAlias(\u0026#34;glad\u0026#34;, \u0026#34;pleased\u0026#34;) viper.Set(\u0026#34;glad\u0026#34;, \u0026#34;happy\u0026#34;) viper.GetString(\u0026#34;pleased\u0026#34;)\t// happy with flag #  // 使用标准库 flag flag.String(\u0026#34;config\u0026#34;, \u0026#34;app.toml\u0026#34;, \u0026#34;config filename\u0026#34;) flag.Parse() // 设置pflag pflag.CommandLine.AddGoFlagSet(flag.CommandLine)\t// 若以上使用pflag，无需此操作 viper.BindPFlags(pflag.CommandLine) viper.GetString(\u0026#34;config\u0026#34;) "},{"id":2,"href":"/docs/linux/cmd/","title":"常用命令","section":"Linux","content":"前言 #  命令按字母排序\nawk #  # 每行 替换字符串A为B，并打印第一列(空格或TAB分割) awk \u0026#39;{ sub(/A/, \u0026#34;B\u0026#34;); print $1}\u0026#39; "}]